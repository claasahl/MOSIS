package de.claas.mosis.graphs;

import de.claas.mosis.flow.Graph;
import de.claas.mosis.flow.iterator.InfiniteLevelOrder;
import de.claas.mosis.io.StandardInputOutputImpl;
import de.claas.mosis.io.format.PlainText;
import de.claas.mosis.io.generator.Linear;
import de.claas.mosis.model.Processor;
import de.claas.mosis.processing.debug.ToString;

/**
 * The class {@link LoopedSequence} is a sample demonstrator. It is intended to
 * show the use of a (simple) sequential information flow, in which a loop
 * exist. Here the basic sequence is based on only two {@link Processor} objects
 * (i.e. a source and a sink).
 * 
 * @author Claas Ahlrichs (claasahl@tzi.de)
 * 
 */
public class LoopedSequence {

    /**
     * Entry point for this demonstrator. Here a linear function is generated by
     * one module and displayed by another. The latter module's results are fed
     * into itself again. The function's slope and intercept can be varied by
     * changing the method's arguments.
     * 
     * @param args
     *            the arguments, namely slope (i.e. {@link Linear#M}) and
     *            intercept (i.e. {@link Linear#B}).
     */
    public static void main(String[] args) throws Exception {
	// Prepare processing modules
	Linear src = new Linear();
	src.setParameter(Linear.M, args.length >= 1 ? args[0] : "1");
	src.setParameter(Linear.B, args.length >= 2 ? args[1] : "0");
	ToString toString = new ToString();
	PlainText dst = new PlainText();
	dst.setParameter(PlainText.IMPL,
		StandardInputOutputImpl.class.getName());

	// Construct graph and initiate processing
	Graph graph = new Graph();
	graph.addLink(src, toString);
	graph.addLink(toString, dst);
	graph.addLink(dst, dst);
	graph.process(InfiniteLevelOrder.class);
    }

}
